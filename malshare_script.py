import json
import calendar
import sqlite3
import time
from datetime import datetime
from multiprocessing.dummy import Pool as ThreadPool
import requests
import config
import malshare_utils
import urllib.request
import os
from tqdm import tqdm
import argparse


parser = argparse.ArgumentParser(prog='malshare_script.py',
                                 description='################### MALSHARE SCRIPT ###################',
                                 formatter_class=lambda prog: argparse.HelpFormatter(prog, max_help_position=50))

parser.add_argument('--untilyesterday', '-uyes', action='store_true',
                    help='Get hashes until yesterday.')

parser.add_argument('--hash2detail', '-h2d', action='store_true',
                    help='Take the data from hashes database and create details database.')

parser.add_argument('--sources24', '-s24', action='store_true',
                    help='Gets the sources for last 24 hours.')

parser.add_argument('--update24', '-up24', action='store_true',
                    help='Updates the intended database with the data of last day.')

parser.add_argument('--bydate', '-bd', type=malshare_utils.valid_datetime_type,
                    help='Creates a database with the hashes of intended date.', )

parser.add_argument('--update', '-up', action='store_true',
                    help='Updates the intended database with the current data on website. ')


args = parser.parse_args()


class MalshareDump:
    try:
        # Date of the first archive directory that I can access which is 2017-09-14 in epoch format.
        big_list = []
        api_key = config.malshare_api_key

        if args.update24 or args.update:
            hashes_db = config.database_folder + config.fixed_hashes_db
            details_db = config.api_database_folder + config.malshare_db_name
        else:
            hashes_db = config.database_folder + config.hashes_db_name
            details_db = config.database_folder + config.details_db_name

        if args.sources24 or args.untilyesterday or args.bydate:
            try:
                if not config.hashes_db_name:
                    print("config.hashes_db_name cannot be empty...")
                    os._exit(0)
                elif config.details_db_name:
                    details_db = ""
            except:
                pass

        elif args.hash2detail:
            try:
                if not config.hashes_db_name:
                    print("config.hashes_db_name cannot be empty...")
                    os._exit(0)
                elif not config.details_db_name:
                    print("config.details_db_name cannot be empty...")
                    os._exit(0)
            except:
                pass

        elif args.update24:
            try:
                if not config.fixed_hashes_db:
                    print("config.fixed_hashes_db cannot be empty...")
                    os._exit(0)
                elif not config.malshare_db_name:
                    print("config.malshare_db_name cannot be empty...")
                    os._exit(0)
            except:
                pass

        elif args.update:
            try:
                if config.fixed_hashes_db:
                    hashes_db = ""
                if not config.malshare_db_name:
                    print("config.malshare_db_name cannot be empty...")
                    os._exit(0)
            except:
                pass

        try:
            conn_hashes_db = sqlite3.connect(hashes_db)
        except:
            if args.update:
                pass

        try:
            conn_details_db = sqlite3.connect(details_db)
        except:
            if args.sources24 or args.untilyesterday or args.bydate:
                pass

    except:
        pass

    current_datetime = 0

    @staticmethod
    def datetime_of_now():
        MalshareDump.current_datetime = datetime.now().strftime('%Y-%m-%d %H:%M:%S')


def insert_hashes(list_about_to_insert, dateinsert):
    c = MalshareDump.conn_hashes_db.cursor()
    malware_source_list = []

    for item in list_about_to_insert:
        malware_source_list.append((item, dateinsert))

    c.executemany("INSERT OR IGNORE INTO hash_data VALUES(?, ?);", malware_source_list, )
    MalshareDump.conn_hashes_db.commit()
    c.close()


def past_24_hours_sources():
    url = 'https://malshare.com/api.php?api_key={}&action=getsources'.format(MalshareDump.api_key)

    ts = calendar.timegm(time.gmtime())
    dateinsert = ts - 86400

    r = requests.get(url)
    tmp_list = r.json()
    list_of_sources = []

    for item in tmp_list:
        if item:
            list_of_sources.append(item)

    c = MalshareDump.conn_hashes_db.cursor()

    malware_source_list = []

    for item in list_of_sources:
        malware_source_list.append((item, dateinsert))

    c.executemany("INSERT OR IGNORE INTO source_data VALUES(?, ?);", malware_source_list, )
    MalshareDump.conn_hashes_db.commit()
    c.close()


def get_date(intended_hash):
    conn = sqlite3.connect(MalshareDump.hashes_db)
    c8 = conn.cursor()
    intended_hash = intended_hash[0]
    c8.execute('SELECT date from hash_data where hash=?  ', (intended_hash,))

    rows = c8.fetchone()
    hash_date = rows[0]
    c8.close()
    return hash_date


def create_hashes_db_of_specific_date(intended_date):
    specific_date_malware_list = malshare_utils.get_malware_daily(intended_date)
    epoch_of_intended_date = int(datetime.strptime(intended_date, '%Y-%m-%d').timestamp())
    epoch_of_intended_date += 10800  # To convert the date into GMT. Modify the value according to your own time zone.
    insert_hashes(specific_date_malware_list, epoch_of_intended_date)


def get_hashes_until_yesterday(epoch_of_hash):
    unix_time = malshare_utils.epoch_of_yesterday()
    while epoch_of_hash < unix_time:
        date_of_hash = time.strftime('%Y-%m-%d', time.localtime(epoch_of_hash))
        daily_malware_list = malshare_utils.get_malware_daily(date_of_hash)
        try:
            insert_hashes(daily_malware_list, epoch_of_hash)
        except:
            pass
        epoch_of_hash += 86400  # Sets epoch of hash to next day of previous one.


def insert_bigdata():
    conn = sqlite3.connect(MalshareDump.details_db)
    c = conn.cursor()
    c.executemany("INSERT OR IGNORE INTO data VALUES(?, ?, ?, ?);", MalshareDump.big_list, )
    conn.commit()
    c.close()
    conn.close()
    MalshareDump.big_list.clear()


def multithread_function(hash_row):
    insertion_list = malshare_utils.fetch_hash_details(hash_row)
    try:
        for item in insertion_list['SOURCES']:
            if item is not None:  # Checks if is there any null or empty source info.
                MalshareDump.big_list.append(
                    (insertion_list['MD5'], insertion_list['F_TYPE'], item.strip(), get_date(hash_row)))
    except:
        pass

    if len(MalshareDump.big_list) >= 5000:
        insert_bigdata()

    pbar.update(1)


def get_details_into_db():
    global pbar
    c1 = MalshareDump.conn_hashes_db.cursor()
    c1.execute('SELECT hash FROM hash_data')
    hash_rows = c1.fetchall()
    c1.close()

    if not hash_rows:
        print("The database that should contains hashes is empty.")
        print("Terminating...")
        os._exit(0)

    thread_pool_value = 10
    tqdm.monitor_interval = len(hash_rows) / thread_pool_value / 10

    pbar = tqdm(total=len(hash_rows))
    pool = ThreadPool(thread_pool_value)

    for _ in tqdm(pool.imap_unordered(multithread_function, hash_rows)):
        pass

    pool.close()
    pool.join()

    insert_bigdata()  # for the remaining data which is less than 5000 rows.


def get_last_day_details_into_db():
    # epoch_of_hash = malshare_utils.epoch_of_yesterday()   # Uncomment for getting epoch format.
    # date_of_hash = time.strftime('%Y-%m-%d', time.localtime(epoch_of_hash))   # Uncomment for getting epoch format.
    date_of_hash = malshare_utils.datetime_of_yesterday()   # Comment for getting epoch format of date.
    last_day_malware_list = malshare_utils.get_malware_daily(date_of_hash)

    c = MalshareDump.conn_hashes_db.cursor()
    malware_source_list = []

    for item in last_day_malware_list:
        malware_source_list.append((item, date_of_hash))

    c.executemany("INSERT OR IGNORE INTO hash_data VALUES(?, ?)", malware_source_list, )

    MalshareDump.conn_hashes_db.commit()

    c.close()
    get_details_into_db()


def multithread_fetch_daily_malshare_list(list_item):
    insertion_list = malshare_utils.fetch_hash_details(list_item['md5'])

    for item in insertion_list['SOURCES']:
        if item is not None:  # Checks if is there any null or empty source info.
            MalshareDump.big_list.append(
                (insertion_list['MD5'], insertion_list['F_TYPE'], item.strip(), MalshareDump.current_datetime))

    if len(MalshareDump.big_list) % 500 == 0:  # To check how big is the big_list currently.
        print("Big_list current size: " + str(len(MalshareDump.big_list)))
    if len(MalshareDump.big_list) >= 5000:
        insert_bigdata()

    bar.update(1)


def fetch_daily_malshare_list():
    global bar
    MalshareDump.datetime_of_now()
    url = 'https://malshare.com/api.php?api_key={}&action=getlist'.format(MalshareDump.api_key)
    request = urllib.request.urlopen(url)
    hash_list = json.loads(request.read().decode())

    thread_pool_value = 10
    tqdm.monitor_interval = len(hash_list) / thread_pool_value / 10

    bar = tqdm(total=len(hash_list[-200:]))
    pool = ThreadPool(thread_pool_value)

    for _ in tqdm(pool.imap_unordered(multithread_fetch_daily_malshare_list, hash_list[-200:])):
        pass

    pool.close()
    pool.join()

    insert_bigdata()


def initialize():
    try:
        c = MalshareDump.conn_details_db.cursor()
        c.execute("CREATE TABLE IF NOT EXISTS data (hash text, f_type text, source text, date number)")
        c.execute('CREATE UNIQUE INDEX IF NOT EXISTS source_index ON data(source)')
        c.close()
    except:
        pass

    try:
        c = MalshareDump.conn_hashes_db.cursor()
        c.execute("CREATE TABLE IF NOT EXISTS hash_data (hash text, date number)")
        c.execute("CREATE TABLE IF NOT EXISTS source_data (source text, date number)")
        c.execute('CREATE UNIQUE INDEX IF NOT EXISTS hash_index ON hash_data(hash)')
        c.execute('CREATE UNIQUE INDEX IF NOT EXISTS source_index ON source_data(source)')
        c.close()
    except:
        pass


def main():
    if args.untilyesterday:
        initialize()
        get_hashes_until_yesterday(config.first_epoch_of_hash)
        # config.hashes_db_name -> Put the name of the .db that you would like to fetch and insert into since 2017-14-09 until yesterday. (except yesterday)
        # config.details_db_name -> Leave it empty.

    elif args.hash2detail:
        initialize()
        get_details_into_db()
        # config.hashes_db_name -> Put .db which contains the hashes and dates that you want to get the details.
        # config.details_db_name -> Put .db which is the target to be inserted.

    elif args.sources24:
        initialize()
        past_24_hours_sources()
        # config.hashes_db_name -> Put the name of the .db that will be created for the sources since past 24 hours.
        # config.details_db_name -> Leave it empty.

    elif args.update24:
        initialize()
        get_last_day_details_into_db()
        # config.fixed_hashes_db -> Put the name of the .db that will be created for the hashes of yesterday.
        # config.malshare_db_name -> Put the name of the .db that will be updated with details of yesterday.
        # Run this after 01.30 am (GMT).

    elif args.bydate:
        initialize()
        create_hashes_db_of_specific_date(args.bydate)
        # Type the date that you want to get it's hashes in yyyy-mm-dd format.
        # config.hashes_db_name -> Put the name of .db that will be created for the hashes of intended date.
        # config.details_db_name -> Leave it empty.

    elif args.update:
        initialize()
        fetch_daily_malshare_list()
        # Updates intended db that contains the details of hashes.
        # config.hashes_db_name -> Leave it empty.
        # config.malshare_db_name -> Put the name of .db which will be updated.

    else:
        print("No arguments. Run with --help or -h argument for further information.")

    return


if __name__ == '__main__':
    main()
